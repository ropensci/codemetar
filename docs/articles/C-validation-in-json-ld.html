<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Validation in JSON-LD • codemetar</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">codemetar</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/A-codemeta-intro.html">Codemeta intro</a>
    </li>
    <li>
      <a href="../articles/B-translating.html">Translating between schema using JSON-LD</a>
    </li>
    <li>
      <a href="../articles/C-validation-in-json-ld.html">Validation in JSON-LD</a>
    </li>
    <li>
      <a href="../articles/D-codemeta-parsing.html">Parsing Codemeta Data</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/ropensci/codemetar">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Validation in JSON-LD</h1>
                        <h4 class="author">Carl Boettiger</h4>
            
            <h4 class="date">2018-02-15</h4>
          </div>

    
    
<div class="contents">
<div id="introduction" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h2>
<p>Schema validation is a useful and important concept to the distribution of metadata in formats such as XML and JSON, in which the standard-provider creates a schema (specified in an XML-schema, XSD, for XML documents, or <a href="http://json-schema.org/">json-schema</a> for JSON documents). Schemas allow us to go beyond the basic notation of making sure a file is simply valid XML or valid JSON, a requirement just to be read in by any parser. By detailing how the metadata must be structured, what elements must, can, and may not be included, and what data types may be used for those elements, schema help developers consuming the data to anticipate these details and thus build applications which know how to process them. For the data creator, validation is a convenient way to catch data input errors and ensure a consistent data structure.</p>
<p>Because schema validation must ensure predictable behavior without knowledge of what any specific application is going to do with the data, it tends to be very strict. A simple application may not care if certain fields are missing or if integers are mistaken for characters, while to another application these differences could lead it to throw fatal errors.</p>
<p>The approach of JSON-LD is less prescriptive. JSON-LD uses the notion of “framing” to let each application specify how it expects it data to be structured. JSON frames allow each developer consuming the data to handle many of the same issues that schema validation have previously assured. Readers should consult the <a href="https://json-ld.org/spec/latest/json-ld-framing/">official json-ld framing</a> documentation for details on this approach.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(jsonld)
<span class="kw">library</span>(jsonlite)
<span class="kw">library</span>(magrittr)
<span class="kw">library</span>(codemetar)</code></pre></div>
</div>
<div id="a-motivating-example" class="section level2">
<h2 class="hasAnchor">
<a href="#a-motivating-example" class="anchor"></a>A motivating example:</h2>
<p>Consider the following codemeta document:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">codemeta &lt;-<span class="st"> </span>
<span class="st">'</span>
<span class="st">{</span>
<span class="st">  "@context": "http://purl.org/codemeta/2.0",</span>
<span class="st">  "@type": "SoftwareSourceCode",</span>
<span class="st">  "name": "codemetar: Generate CodeMeta Metadata for R Packages",</span>
<span class="st">  "datePublished":" 2017-05-20",</span>
<span class="st">  "version": 1.0,</span>
<span class="st">  "author": [</span>
<span class="st">    {</span>
<span class="st">      "@type": "Person",</span>
<span class="st">      "givenName": "Carl",</span>
<span class="st">      "familyName": "Boettiger",</span>
<span class="st">      "email": "cboettig@gmail.com",</span>
<span class="st">      "@id": "http://orcid.org/0000-0002-1642-628X"</span>
<span class="st">    }],</span>
<span class="st">  "maintainer":  {"@id": "http://orcid.org/0000-0002-1642-628X"}</span>
<span class="st">}</span>
<span class="st">'</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">jsonld<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/jsonld/topics/jsonld">jsonld_compact</a></span>(codemeta, <span class="st">"http://purl.org/codemeta/2.0"</span>)</code></pre></div>
<pre><code>{
  "@context": "http://purl.org/codemeta/2.0",
  "type": "SoftwareSourceCode",
  "author": [
    {
      "id": "http://orcid.org/0000-0002-1642-628X",
      "type": "Person",
      "email": "cboettig@gmail.com",
      "familyName": "Boettiger",
      "givenName": "Carl"
    }
  ],
  "datePublished": " 2017-05-20",
  "name": "codemetar: Generate CodeMeta Metadata for R Packages",
  "version": 1,
  "maintainer": {
    "id": "http://orcid.org/0000-0002-1642-628X"
  }
} </code></pre>
</div>
<div id="framing-subsetting-data" class="section level2">
<h2 class="hasAnchor">
<a href="#framing-subsetting-data" class="anchor"></a>Framing: subsetting data</h2>
<p>By default, frames return all the input data, while our application may only be interested in some subset. Often it is sufficient just to ignore these additional terms: in the example above it’s just as easy for our application to work with author elements whether or not we have dropped other elements such as <code>meta$version</code>. To restrict a frame to returning only the nodes we explicitly mention, we can use the keyword <code>@explicit</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">frame &lt;-<span class="st"> '{</span>
<span class="st">  "@context": "http://purl.org/codemeta/2.0",</span>
<span class="st">  "@explicit": "true",</span>
<span class="st">  "@type": "Person",</span>
<span class="st">  "givenName": {},</span>
<span class="st">  "familyName": {}</span>
<span class="st">}'</span>

meta &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="http://www.rdocumentation.org/packages/jsonld/topics/jsonld">jsonld_frame</a></span>(codemeta, frame)  <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw"><a href="http://www.rdocumentation.org/packages/jsonlite/topics/fromJSON">fromJSON</a></span>(codemeta, <span class="dt">simplifyVector =</span> <span class="ot">FALSE</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">getElement</span>(<span class="st">"@graph"</span>) 

meta[[<span class="dv">1</span>]]</code></pre></div>
<pre><code>$id
[1] "http://orcid.org/0000-0002-1642-628X"

$type
[1] "Person"

$familyName
[1] "Boettiger"

$givenName
[1] "Carl"</code></pre>
<p>Note that this has only returned the requested fields in the graph (along with the <code>@id</code> and <code>@type</code>, which are always included if provided, since they may be required to interpret the data properly). This frame extracts the <code>givenName</code> and <code>familyName</code> of any <code>Person</code> node it finds, regardless of where it occurs, while ommitting the rest of the data. Note that since the frame requests these elements at the top level, they are returned as such, with each match a separate entry in the <code>@graph</code>. Our example has only one person in <code>meta[[1]]</code>, had we more matches they would appear in <code>meta[[2]]</code>, etc. Note these returns are un-ordered.</p>
</div>
<div id="framing-expanding-node-references" class="section level2">
<h2 class="hasAnchor">
<a href="#framing-expanding-node-references" class="anchor"></a>Framing: expanding node references</h2>
<p>The same underlying data can often be expressed in different ways, particularly when dealing with nested data. Framing can be of great help here to reshape the data into the structure required by the application. For instance, it would be natural to access the <code>email</code> of the <code>maintainer</code> in the same manner we did the author, but this fails for our example as <code>maintainer</code> is defined only by reference to an ID:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">meta &lt;-<span class="st"> </span><span class="kw"><a href="http://www.rdocumentation.org/packages/jsonlite/topics/fromJSON">fromJSON</a></span>(codemeta, <span class="dt">simplifyVector =</span> <span class="ot">FALSE</span>) 
<span class="kw">paste</span>(<span class="st">"For complaints, email"</span>, meta<span class="op">$</span>maintainer<span class="op">$</span>email)</code></pre></div>
<pre><code>[1] "For complaints, email "</code></pre>
<p>We can confirm that <code>maintainer</code> is just an ID:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">meta<span class="op">$</span>maintainer</code></pre></div>
<pre><code>$`@id`
[1] "http://orcid.org/0000-0002-1642-628X"</code></pre>
<p>We can use a frame with the special directive <code>"@embed": "@always"</code> to say that we want the full maintainer information embedded an not just referred to by id alone. Then we can subset <code>maintainer</code> just like we do author.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">frame &lt;-<span class="st"> '{</span>
<span class="st">  "@context": "http://purl.org/codemeta/2.0",</span>
<span class="st">  "@embed": "@always"</span>
<span class="st">}'</span>


meta &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="http://www.rdocumentation.org/packages/jsonld/topics/jsonld">jsonld_frame</a></span>(codemeta, frame) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw"><a href="http://www.rdocumentation.org/packages/jsonlite/topics/fromJSON">fromJSON</a></span>(codemeta, <span class="dt">simplifyVector =</span> <span class="ot">FALSE</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">getElement</span>(<span class="st">"@graph"</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">getElement</span>(<span class="dv">1</span>)</code></pre></div>
<p>Now we can do</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">paste</span>(<span class="st">"For complaints, email"</span>, meta<span class="op">$</span>maintainer<span class="op">$</span>email)</code></pre></div>
<pre><code>[1] "For complaints, email cboettig@gmail.com"</code></pre>
<p>and see that <code>email</code> has been successfully returned from the matching ID under author data.</p>
</div>
<div id="handling-unexpected-types" class="section level2">
<h2 class="hasAnchor">
<a href="#handling-unexpected-types" class="anchor"></a>Handling unexpected types</h2>
<p>JSON-LD routines will simply refuse to compact data if the type differs from what the context expects. Here is a sample data file that declares that the <code>buildInstructions</code> are included as text, which differs from the <code>context</code> file which explicitly states that <code>buildInstructions</code> should be a URL:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">codemeta &lt;-<span class="st"> </span>
<span class="st">'</span>
<span class="st">{</span>
<span class="st">  "@context": "https://purl.org/codemeta/2.0",</span>
<span class="st">  "@type": "SoftwareSourceCode",</span>
<span class="st">  "name": "codemetar: Generate CodeMeta Metadata for R Packages",</span>
<span class="st">  "buildInstructions": { </span>
<span class="st">      "@value": "Just install this package using devtools::install_github", </span>
<span class="st">      "@type": "Text"</span>
<span class="st">  }</span>
<span class="st">}</span>
<span class="st">'</span></code></pre></div>
<p>When we perform a framing or compaction operation, <code>buildInstructions</code> gets de-referenced to <code>codemeta:buildInstructions</code>, because it does not match the context. This means that if our application asks for <code>meta$buildInstructions</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">meta &lt;-
<span class="st">  </span><span class="kw"><a href="http://www.rdocumentation.org/packages/jsonld/topics/jsonld">jsonld_frame</a></span>(codemeta, <span class="st">'{"@context": "https://purl.org/codemeta/2.0"}'</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="http://www.rdocumentation.org/packages/jsonlite/topics/fromJSON">fromJSON</a></span>(codemeta, <span class="dt">simplifyVector =</span> <span class="ot">FALSE</span>) <span class="op">%&gt;%</span><span class="st">  </span>
<span class="st">  </span><span class="kw">getElement</span>(<span class="st">"@graph"</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">getElement</span>(<span class="dv">1</span>)    

## above is same as compacting:
<span class="co">#jsonld_compact(codemeta, "http://purl.org/codemeta/2.0") %&gt;% </span>
<span class="co">#  fromJSON(codemeta, simplifyVector = FALSE)</span>

meta<span class="op">$</span>buildInstructions</code></pre></div>
<pre><code>NULL</code></pre>
<p>We just get <code>NULL</code>, rather than some unexpected type of object (e.g. a string that is not a URL.) Note that the data is not lost, but simply not dereferenced:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(meta)</code></pre></div>
<pre><code>[1] "id"                         "type"                      
[3] "name"                       "codemeta:buildInstructions"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">meta[<span class="st">"codemeta:buildInstructions"</span>]</code></pre></div>
<pre><code>$`codemeta:buildInstructions`
$`codemeta:buildInstructions`$type
[1] "Text"

$`codemeta:buildInstructions`$`@value`
[1] "Just install this package using devtools::install_github"</code></pre>
<p>Note that this behavior only happens because the data declared the <code>"@type": "Text"</code> explicitly. JSON-LD algorithms only believe what they are told about type and only look for consistency in declared types. If you give text but declare it as a <code>"@type": "URL"</code>, or don’t declare the type at all, JSON-LD algorithms won’t know anything is amiss and the property will be compacted as usual.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li><a href="#a-motivating-example">A motivating example:</a></li>
      <li><a href="#framing-subsetting-data">Framing: subsetting data</a></li>
      <li><a href="#framing-expanding-node-references">Framing: expanding node references</a></li>
      <li><a href="#handling-unexpected-types">Handling unexpected types</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Carl Boettiger.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
